笛卡尔树
定义和Treap相同：（Treap是权值随机的笛卡尔树）
1：k满足二叉搜索树性质，也就是中序遍历从小到大
2：w满足小根堆性质，也就是上面的一定比下面大

正常构建的Treap应该是下标为w，元素为k（可以模拟插入过程理解），因为后插入的一定在前面节点的下面，
所以下标是w，而元素要从小到大排列，所以是k

一个有趣的事实是，如果笛卡尔树的 (k,w)键值确定、并且k不相同，w不相同，那么这个笛卡尔树的结构是唯一的。

例题： luogu5854 
给定一个 1~n 的排列 p，构建其笛卡尔树。
即构建一棵二叉树，满足：
1.每个节点的编号满足二叉搜索树的性质。
2.节点 i的权值为 p_i，每个节点的权值满足小根堆的性质。

定义一棵树的右链为从根出发一直往右儿子方向能够到达的所有点按照深度从浅到深排序后而形成的一条链。
因为我们的键值 k 是数组下标，所以我们不需要排序，直接从数组的左边往右边插入可以。
假设我们现在插入的是节点 u，我们为了维护下标满足二叉搜索树的性质，肯定每次都是往树的右链的末端插入，
但是我们此时要维护堆的性质。
1. 如果恰好 w_u  大于当前右链末端端点的 w即直接将 u插入到 右链的末端。
2. 如果 w_u小于当前右链的末端端点的 w，那么意味着 u 应当在树上是 当前右链 末端端点的祖先，
于是我们继续往上找，直到遇到满足第一种情况的点。
而这个右链，其实就是一个关于w递增的单调栈

#include<bits/stdc++.h>
#define ll long long
#define inf 1e18
#define mn 10000005
using namespace std;
ll s[mn],c[mn][2],a[mn],top=0,ans=0,ans2=0,n,m;
inline void in(ll &x)
{
   ll s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
   x=s*w;
}
int main()
{
	ll x,y,z,i,j,k;
	char ch;
	cin>>n;
	for(i=1;i<=n;i++)
		in(a[i]); 
	for(i=1;i<=n;i++)
	{
		ll pos=top;
		while(pos&&a[s[pos]]>a[i])pos--;
		if(pos)c[s[pos]][1]=i;
		if(pos<top)c[i][0]=s[pos+1];
		top=pos+1;
		s[top]=i;
	}
	//上面就是建树的过程，下面是求题目要求的答案 
	for(i=1;i<=n;i++)
	{
		ans^=i*(c[i][0]+1);
		ans2^=i*(c[i][1]+1);
	}
	cout<<ans<<" "<<ans2;
	return 0;
}

例题：luogu1377
众所周知，二叉查找树的形态和键值的插入顺序密切相关。准确的讲：
1、空树中加入一个键值k，则变为只有一个结点的二叉查找树，此结点的键值即为k
2、在非空树中插入一个键值k，若k小于其根的键值，则在其左子树中插入k，否则在其右子树中插入k
我们将一棵二叉查找树的键值插入序列称为树的生成序列，现给出一个生成序列，
求与其生成同样二叉查找树的所有生成序列中字典序最小的那个

发现建出来二叉树以后再先序遍历就是最小的字典序生成序列，但是暴力建树需要o（n*n）
可以发现，其权值按照二叉树性质，也就是中序遍历从小到大排列，而后面出现的值一定在前面的值的下面，
也就是说其节点编号按照小根堆性质排列，也就是上面的比下面的小，所以
for(i=1;i<=n;i++){read(x);a[x]=i;} 
读入数据后然后再建出树，然后先序遍历即可 
