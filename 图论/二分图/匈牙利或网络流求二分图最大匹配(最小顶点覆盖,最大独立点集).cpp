匹配的意思是，从二分图中的边集选出一个子集，使得这个子集中的所有边，都不会交汇于同一个点
最大匹配的意思就是一个二分图中能选出来的边数最多的匹配
而匈牙利算法可以解决这种问题，复杂度为 O(n*e+m)，其中n是左部点个数，e是图的边数，m是右部点个数。

假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。
定理：最小顶点覆盖等于二分图的最大匹配 

独立集是一个点集，点集中的各点之间没有连边。
最大独立集=点的总数-最小顶点覆盖
如果去掉这些点，相应的关系（边）也都没有了。剩下的点之间就相互没有关系，就变成了独立集。

luogu3386：二分图最大匹配
注意图中连的都是从左到右的单向边 

另外，二分图匹配可以使用最大流算法，将复杂度降低至O(n*sqrt(e)) ，1单位边权的dinic（ISAP）都是这个复杂度
具体的，建立超级源点和超级汇点，源点向左侧连边，右侧向汇点连边。左右之间连边。上述边的流量都是1 。
由于s到点左侧任意一点u的流量是1，所以u最多被选择一次。同理右边的点也最多被选择一次。
于是这个图的网络最大流即为该二分图的最大匹配。

值得注意的是，二分图最大匹配很多时候并不能够裸连边（空间时间承受不了），需要通过一些中介点进行优化，
比方说题目出现质数的时候，就有可能把质因数当做公共节点来进行优化（卡牌配对bzoj4205） 
 
#include<bits/stdc++.h>
#define ll long long
#define inf 1e18
#define mn 1005
using namespace std;
ll g[mn][mn],my[mn],vst[mn],ans=0,n,m;
//n是二分图左边的点集的个数，m是右边的点集的个数
bool dfs(ll i)
{ll j;
	for(j=1;j<=m;j++)
	if(g[i][j]==1&&vst[j]==0)
	{
		vst[j]=1;
		if(my[j]==0||dfs(my[j]))
		{
			my[j]=i;
			return 1;
		}
	}
	return 0;
}
int main()
{
	ll x,y,k,i,j,z;
	char ch;
	cin>>n>>m>>k;//k为边的个数 
	while(k--)//这k条边都是指的是从左边的点集连到右边的点集的单向边 
	{
		scanf("%lld%lld",&x,&y);
		g[x][y]=1;
	}
	memset(my,0,sizeof(my));
	for(i=1;i<=n;i++)
	{
		memset(vst,0,sizeof(vst));
		if(dfs(i))ans++;
	}
	cout<<ans;
	return 0;
}
