01背包（每个东西只有一个）
for(i=1;i<=n;i++)f[i][0]=0;//初始化
for(i=1;i<=m;i++)f[0][i]=0;//初始化
for(i=1;i<=n;i++) //阶段,前i个物品
	for(j=1;j<=m;j++) //状态j重量
	{	 
		f[i][j]=f[i-1][j];
		if(j>=w[i]&&f[i][j]<f[i-1][j-w[i]]+c[i])
		f[i][j]=f[i-1][j-w[i]]+c[i];
	}
for(i=1;i<=n;i++)
	for(j=m;j>=w[i];j--)//倒序枚举 
	if(f[j-w[i]]+c[i]>f[j])
	f[j]=f[j-w[i]]+c[i]; 
有很多问题可以变形转换为01背包问题，就是把某种选择或者限制拆分为多个物体以进行背包dp
当然还有二维的01背包也是差不多的 
分组背包问题（多个组，每个组里只能选一个）也跟这个差不多 
值得注意的是，很多时候01背包会把i这一维压掉，只留j这一维，这个时候就需要倒着枚举j（重点） 

完全背包（每个东西有无限个） 
cin>>m>>n;
for(i=1;i<=n;i++)cin>>w[i]>>c[i];
memset(f,0,sizeof(f));
for(i=1;i<=n;i++)
	for(j=1;j<=m;j++)
	{
		f[i][j]=f[i-1][j];
		if(j>=w[i]&&f[i][j]<f[i][j-w[i]]+c[i])
		f[i][j]=f[i][j-w[i]]+c[i];//因为他可以反复取，所以可以影响当前状态的值 
	}
cout<<f[n][m]<<endl;

cin>>m>>n; //容量和物品数目
for(i=1;i<=m;i++)f[i]=0;//初始化
for(i=1;i<=n;i++)cin>>w[i]>>c[i];//重量和价格
for(i=1;i<=n;i++)//物品数
	for(j=w[i];j<=m;j++)//容量
	f[j]=max(f[j],f[j-w[i]]+c[i]);
cout<<f[m]<<endl;

多重背包（每个东西有很多个，但是是有限的）
现在考虑二进制的思想，我们考虑把第i种物品换成若干件物品，
使得原问题中第i种物品可取的每种策略――取0..a[i]件――均能等
价于取若干件代换以后的物品。 

比如13=1+2+4+6然后就很简单了 
