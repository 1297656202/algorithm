概率dp可以直接正着推，就把当前状态的概率按照比值分给他能达到的状态就好
而期望dp往往是反着推的，比如说下面的这道例题： 

问题：一个r行c列的格子，起始点在（1,1），终点在（r,c），每
一步可能的走法有：不动、向右走、向下走，每走一步花费两点
魔法值，现给出在每一点三种走法的概率，求走完迷宫时所花魔
法值的期望。
 
如果说我们是正着推，那么f[i][j]=f[i-1][j]*p1+f[i][j-1]*p2+f[i][j]*p3;
我们现在知道的是对于每个点而言走出去的概率，但是我们不知道对于一个点从各个地方走进来的概率
所以要算出p1,p2,p3需要知道到达f[i-1][j],f[i][j-1],f[i][j]的概率，
然后再分别乘上对应点的向下走，向右走和不动的概率，再把三个概率成相同比率扩大，使他们的和等于1，
这样才能求出对于一个点从各个地方走进来的概率，这样实在是太麻烦了，所以我们可以反着推
因为知道的是对于每个点而言走出去的概率，反着推都知道对于f[i][j]每个方向的概率，代码就会简单很多，
但是，如果我们知道从其他点走进来的概率，那么就可以正着推 
 
设f[i,j]表示从(i,j)到(r,c)所花费魔法值的期望
f[i,j]=f[i,j]*p[i,j,1]+f[i,j+1]*p[i,j,2]+f[i+1,j]*p[i,j,3]+2
其中p[i,j,k]代表在点(i,j)选择第k种走法的概率
再化简一下：
f[i,j]=(f[i,j+1]*p[i,j,2]+f[i+1][j]*p[i,j,3]+2)/(1-p[i][j][1])
边界条件：f[r,c]=0，因为当在点(r,c)时，他不需要花费魔法值就可
以到达(r,c)，这样我们就可以从后往前递推了，那么要求的答案不就是f[1,1]么！
注意有的格子p1为1的时候，这个格子是不能到的，他一直在原地，
我们不处理它并且把他的期望置为0，不对其他格子产生影响

